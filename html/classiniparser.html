<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>iniparser: iniparser Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">iniparser
   &#160;<span id="projectnumber">3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="moduleiniparser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iniparser Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wrapper for iniparser.  
 <a href="classiniparser.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13ebcb955f6d27429934efb2f9444371"><td class="memItemLeft" align="right" valign="top">integer(c_int) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a13ebcb955f6d27429934efb2f9444371">iniparser_getnsec</a> (dic)</td></tr>
<tr class="memdesc:a13ebcb955f6d27429934efb2f9444371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of sections in a dictionary.  <a href="#a13ebcb955f6d27429934efb2f9444371">More...</a><br/></td></tr>
<tr class="separator:a13ebcb955f6d27429934efb2f9444371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fd5cd849d81f39223ec53605c5a9ad"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a86fd5cd849d81f39223ec53605c5a9ad">iniparser_getsecname</a> (result, dic, n)</td></tr>
<tr class="memdesc:a86fd5cd849d81f39223ec53605c5a9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name for section n in a dictionary.  <a href="#a86fd5cd849d81f39223ec53605c5a9ad">More...</a><br/></td></tr>
<tr class="separator:a86fd5cd849d81f39223ec53605c5a9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df9a5554c77d8993a14d5100062b94a"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a6df9a5554c77d8993a14d5100062b94a">iniparser_dump_ini</a> (dic, filename, mode)</td></tr>
<tr class="memdesc:a6df9a5554c77d8993a14d5100062b94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a dictionary to a loadable ini file.  <a href="#a6df9a5554c77d8993a14d5100062b94a">More...</a><br/></td></tr>
<tr class="separator:a6df9a5554c77d8993a14d5100062b94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee40e5809413cf0dcea17a85dedac6c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a9ee40e5809413cf0dcea17a85dedac6c">iniparser_dumpsection_ini</a> (dic, sec, filename, mode)</td></tr>
<tr class="memdesc:a9ee40e5809413cf0dcea17a85dedac6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a dictionary section to a loadable ini file.  <a href="#a9ee40e5809413cf0dcea17a85dedac6c">More...</a><br/></td></tr>
<tr class="separator:a9ee40e5809413cf0dcea17a85dedac6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ffda51ea62fe9c34039a0310930ce1"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a61ffda51ea62fe9c34039a0310930ce1">iniparser_dump</a> (dic, filename, mode)</td></tr>
<tr class="memdesc:a61ffda51ea62fe9c34039a0310930ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a dictionary to an opened file pointer.  <a href="#a61ffda51ea62fe9c34039a0310930ce1">More...</a><br/></td></tr>
<tr class="separator:a61ffda51ea62fe9c34039a0310930ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b432013880ab3fec116bf2841a72f92"><td class="memItemLeft" align="right" valign="top">integer(c_int) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a0b432013880ab3fec116bf2841a72f92">iniparser_getsecnkeys</a> (dic, sec)</td></tr>
<tr class="memdesc:a0b432013880ab3fec116bf2841a72f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of keys in a section of a dictionary.  <a href="#a0b432013880ab3fec116bf2841a72f92">More...</a><br/></td></tr>
<tr class="separator:a0b432013880ab3fec116bf2841a72f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756ebf793bbe3b428ec2e656bea7a4e6"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a756ebf793bbe3b428ec2e656bea7a4e6">iniparser_getseckeys</a> (result, dic, sec, size)</td></tr>
<tr class="memdesc:a756ebf793bbe3b428ec2e656bea7a4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of keys in a section of a dictionary.  <a href="#a756ebf793bbe3b428ec2e656bea7a4e6">More...</a><br/></td></tr>
<tr class="separator:a756ebf793bbe3b428ec2e656bea7a4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe9e758f48c9ea76b3105690ebb373a"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#aefe9e758f48c9ea76b3105690ebb373a">iniparser_getstring</a> (result, dic, key, notfound)</td></tr>
<tr class="memdesc:aefe9e758f48c9ea76b3105690ebb373a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string associated to a key.  <a href="#aefe9e758f48c9ea76b3105690ebb373a">More...</a><br/></td></tr>
<tr class="separator:aefe9e758f48c9ea76b3105690ebb373a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6b564de064e7ae017e86cdf8814ca9"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#aca6b564de064e7ae017e86cdf8814ca9">iniparser_getstring_array</a> (result, dic, key, delimiters, size)</td></tr>
<tr class="memdesc:aca6b564de064e7ae017e86cdf8814ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string associated to a key, split to an array.  <a href="#aca6b564de064e7ae017e86cdf8814ca9">More...</a><br/></td></tr>
<tr class="separator:aca6b564de064e7ae017e86cdf8814ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b3bb359eb0a37f0501e2283fab2b8a"><td class="memItemLeft" align="right" valign="top">integer(c_int) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a13b3bb359eb0a37f0501e2283fab2b8a">iniparser_getint</a> (dic, key, notfound)</td></tr>
<tr class="memdesc:a13b3bb359eb0a37f0501e2283fab2b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string associated to a key, convert to an int.  <a href="#a13b3bb359eb0a37f0501e2283fab2b8a">More...</a><br/></td></tr>
<tr class="separator:a13b3bb359eb0a37f0501e2283fab2b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae071c7cc51de3533eb06aec53285eaf6"><td class="memItemLeft" align="right" valign="top">integer(c_int) function, <br class="typebreak"/>
dimension(:), allocatable, <br class="typebreak"/>
public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#ae071c7cc51de3533eb06aec53285eaf6">iniparser_getint_array</a> (dic, key, delimiters, size)</td></tr>
<tr class="memdesc:ae071c7cc51de3533eb06aec53285eaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string associated to a key, convert to an int array.  <a href="#ae071c7cc51de3533eb06aec53285eaf6">More...</a><br/></td></tr>
<tr class="separator:ae071c7cc51de3533eb06aec53285eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf6a7ae92df1a2249ae84ac1f09fd1e"><td class="memItemLeft" align="right" valign="top">real(c_double) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#adaf6a7ae92df1a2249ae84ac1f09fd1e">iniparser_getdouble</a> (dic, key, notfound)</td></tr>
<tr class="memdesc:adaf6a7ae92df1a2249ae84ac1f09fd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string associated to a key, convert to a double.  <a href="#adaf6a7ae92df1a2249ae84ac1f09fd1e">More...</a><br/></td></tr>
<tr class="separator:adaf6a7ae92df1a2249ae84ac1f09fd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ace47361e7b21e573476a2aab19ee2b"><td class="memItemLeft" align="right" valign="top">real(c_double) function, <br class="typebreak"/>
dimension(:), allocatable, <br class="typebreak"/>
public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a1ace47361e7b21e573476a2aab19ee2b">iniparser_getdouble_array</a> (dic, key, delimiters, size)</td></tr>
<tr class="memdesc:a1ace47361e7b21e573476a2aab19ee2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string associated to a key, convert to an double array.  <a href="#a1ace47361e7b21e573476a2aab19ee2b">More...</a><br/></td></tr>
<tr class="separator:a1ace47361e7b21e573476a2aab19ee2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6976a21435045e759fa529a019f279c"><td class="memItemLeft" align="right" valign="top">integer(c_int) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#aa6976a21435045e759fa529a019f279c">iniparser_getboolean</a> (dic, key, notfound)</td></tr>
<tr class="memdesc:aa6976a21435045e759fa529a019f279c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string associated to a key, convert to a boolean.  <a href="#aa6976a21435045e759fa529a019f279c">More...</a><br/></td></tr>
<tr class="separator:aa6976a21435045e759fa529a019f279c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f870f8c005cd8091fd3640ad1dce8"><td class="memItemLeft" align="right" valign="top">integer(c_int) function, <br class="typebreak"/>
dimension(:), allocatable, <br class="typebreak"/>
public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#aab2f870f8c005cd8091fd3640ad1dce8">iniparser_getboolean_array</a> (dic, key, delimiters, notfound, size)</td></tr>
<tr class="memdesc:aab2f870f8c005cd8091fd3640ad1dce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string associated to a key, convert to a boolean array.  <a href="#aab2f870f8c005cd8091fd3640ad1dce8">More...</a><br/></td></tr>
<tr class="separator:aab2f870f8c005cd8091fd3640ad1dce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca3219d1e80cb89da0576ce273935a3"><td class="memItemLeft" align="right" valign="top">integer(c_int) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a4ca3219d1e80cb89da0576ce273935a3">iniparser_set</a> (dic, key, value)</td></tr>
<tr class="memdesc:a4ca3219d1e80cb89da0576ce273935a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an entry in a dictionary.  <a href="#a4ca3219d1e80cb89da0576ce273935a3">More...</a><br/></td></tr>
<tr class="separator:a4ca3219d1e80cb89da0576ce273935a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e39a4b26f87a3ea69b1813639b4f26"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a82e39a4b26f87a3ea69b1813639b4f26">iniparser_unset</a> (dic, key)</td></tr>
<tr class="memdesc:a82e39a4b26f87a3ea69b1813639b4f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an entry in a dictionary.  <a href="#a82e39a4b26f87a3ea69b1813639b4f26">More...</a><br/></td></tr>
<tr class="separator:a82e39a4b26f87a3ea69b1813639b4f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa078eaa6d7e786c4e24402c4a0c84f30"><td class="memItemLeft" align="right" valign="top">integer(c_int) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#aa078eaa6d7e786c4e24402c4a0c84f30">iniparser_find_entry</a> (dic, key)</td></tr>
<tr class="memdesc:aa078eaa6d7e786c4e24402c4a0c84f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if a given entry exists in a dictionary.  <a href="#aa078eaa6d7e786c4e24402c4a0c84f30">More...</a><br/></td></tr>
<tr class="separator:aa078eaa6d7e786c4e24402c4a0c84f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7833514730d102660a1af7ad2a2005b8"><td class="memItemLeft" align="right" valign="top">type(c_ptr) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#a7833514730d102660a1af7ad2a2005b8">iniparser_load</a> (ininame)</td></tr>
<tr class="memdesc:a7833514730d102660a1af7ad2a2005b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an ini file and return an allocated dictionary object.  <a href="#a7833514730d102660a1af7ad2a2005b8">More...</a><br/></td></tr>
<tr class="separator:a7833514730d102660a1af7ad2a2005b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96fa5470ed9fa49b729ce91a2846ab6"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiniparser.html#af96fa5470ed9fa49b729ce91a2846ab6">iniparser_freedict</a> (dic)</td></tr>
<tr class="memdesc:af96fa5470ed9fa49b729ce91a2846ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory associated to an ini dictionary.  <a href="#af96fa5470ed9fa49b729ce91a2846ab6">More...</a><br/></td></tr>
<tr class="separator:af96fa5470ed9fa49b729ce91a2846ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrapper for iniparser. </p>
<p>This file contains the interfaces to C and the library functions for Fortran. </p>
<dl class="section author"><dt>Author</dt><dd>Georg Poppe </dd></dl>
</div><h2 class="groupheader">Member Function/Subroutine Documentation</h2>
<a class="anchor" id="a61ffda51ea62fe9c34039a0310930ce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iniparser::iniparser_dump </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a dictionary to an opened file pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to dump. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of the file where to dump </td></tr>
    <tr><td class="paramname">mode</td><td>String containing the C file access mode. Take a look at the C-function fopen() to get to know the allowed access modes.</td></tr>
  </table>
  </dd>
</dl>
<p>This function prints out the contents of a dictionary, one element by line, onto the provided file pointer. This function is meant for debugging purposes mostly. </p>

</div>
</div>
<a class="anchor" id="a6df9a5554c77d8993a14d5100062b94a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iniparser::iniparser_dump_ini </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a dictionary to a loadable ini file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to dump </td></tr>
    <tr><td class="paramname">filename</td><td>Name of the file where to dump </td></tr>
    <tr><td class="paramname">mode</td><td>String containing the C file access mode. Take a look at the C-function fopen() to get to know the allowed access modes.</td></tr>
  </table>
  </dd>
</dl>
<p>This function dumps a given dictionary into a loadable ini file. </p>

</div>
</div>
<a class="anchor" id="a9ee40e5809413cf0dcea17a85dedac6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iniparser::iniparser_dumpsection_ini </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a dictionary section to a loadable ini file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to dump </td></tr>
    <tr><td class="paramname">sec</td><td>Section name of dictionary to dump </td></tr>
    <tr><td class="paramname">filename</td><td>Name of the file where to dump </td></tr>
    <tr><td class="paramname">mode</td><td>String containing the C file access mode. Take a look at the C-function fopen() to get to know the allowed access modes.</td></tr>
  </table>
  </dd>
</dl>
<p>This function dumps a given section of a given dictionary into a loadable ini file. </p>

</div>
</div>
<a class="anchor" id="aa078eaa6d7e786c4e24402c4a0c84f30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(c_int) function, public iniparser::iniparser_find_entry </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds out if a given entry exists in a dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to search </td></tr>
    <tr><td class="paramname">key</td><td>Name of the key to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer 1 if entry exists, 0 otherwise</dd></dl>
<p>Finds out if a given entry exists in the dictionary. Since sections are stored as keys with NULL associated values, this is the only way of querying for the presence of sections in a dictionary. </p>

</div>
</div>
<a class="anchor" id="af96fa5470ed9fa49b729ce91a2846ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iniparser::iniparser_freedict </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all memory associated to an ini dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to free</td></tr>
  </table>
  </dd>
</dl>
<p>Free all memory associated to an ini dictionary. It is mandatory to call this function before the dictionary object gets out of the current context. </p>

</div>
</div>
<a class="anchor" id="aa6976a21435045e759fa529a019f279c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(c_int) function, public iniparser::iniparser_getboolean </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(c_int), intent(in)&#160;</td>
          <td class="paramname"><em>notfound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string associated to a key, convert to a boolean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to search </td></tr>
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">notfound</td><td>Value to return in case of error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer</dd></dl>
<p>This function queries a dictionary for a key. A key as read from an ini file is given as "section:key". If the key cannot be found, the notfound value is returned.</p>
<p>A true boolean is found if one of the following is matched:</p>
<ul>
<li>A string starting with 'y'</li>
<li>A string starting with 'Y'</li>
<li>A string starting with 't'</li>
<li>A string starting with 'T'</li>
<li>A string starting with '1'</li>
</ul>
<p>A false boolean is found if one of the following is matched:</p>
<ul>
<li>A string starting with 'n'</li>
<li>A string starting with 'N'</li>
<li>A string starting with 'f'</li>
<li>A string starting with 'F'</li>
<li>A string starting with '0'</li>
</ul>
<p>The notfound value returned if no boolean is identified, does not necessarily have to be 0 or 1. </p>

</div>
</div>
<a class="anchor" id="aab2f870f8c005cd8091fd3640ad1dce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(c_int) function, dimension(:), allocatable, public iniparser::iniparser_getboolean_array </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(c_int), intent(in)&#160;</td>
          <td class="paramname"><em>notfound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(c_int), intent(in)&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string associated to a key, convert to a boolean array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to search </td></tr>
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">delimiters</td><td>Delimiter characters </td></tr>
    <tr><td class="paramname">notfound</td><td>Value to return in case of error </td></tr>
    <tr><td class="paramname">size</td><td>Contains the number of result elements after runtime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocatable integer array</dd></dl>
<p>This function queries a dictionary for a key. A key as read from an ini file is given as "section:key". If the key cannot be found, an empty array (size = 0) is returned. The individual values are seperated by the delimeter characters.</p>
<p>A true boolean is found if one of the following is matched:</p>
<ul>
<li>A string starting with 'y'</li>
<li>A string starting with 'Y'</li>
<li>A string starting with 't'</li>
<li>A string starting with 'T'</li>
<li>A string starting with '1'</li>
</ul>
<p>A false boolean is found if one of the following is matched:</p>
<ul>
<li>A string starting with 'n'</li>
<li>A string starting with 'N'</li>
<li>A string starting with 'f'</li>
<li>A string starting with 'F'</li>
<li>A string starting with '0'</li>
</ul>
<p>The notfound value returned if no boolean is identified, does not necessarily have to be 0 or 1.</p>
<p>This function returns a NULL pointer in case of error. </p>

</div>
</div>
<a class="anchor" id="adaf6a7ae92df1a2249ae84ac1f09fd1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(c_double) function, public iniparser::iniparser_getdouble </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(c_double), intent(in)&#160;</td>
          <td class="paramname"><em>notfound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string associated to a key, convert to a double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to search </td></tr>
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">notfound</td><td>Value to return in case of error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>real(c_double)</dd></dl>
<p>This function queries a dictionary for a key. A key as read from an ini file is given as "section:key". If the key cannot be found, the notfound value is returned. </p>

</div>
</div>
<a class="anchor" id="a1ace47361e7b21e573476a2aab19ee2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(c_double) function, dimension(:), allocatable, public iniparser::iniparser_getdouble_array </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(c_int), intent(in)&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string associated to a key, convert to an double array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to search </td></tr>
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">delimiters</td><td>Delimiter characters </td></tr>
    <tr><td class="paramname">size</td><td>Contains the number of result elements after runtime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocatable real(kind=c_double) array</dd></dl>
<p>This function queries a dictionary for a key. A key as read from an ini file is given as "section:key". If the key cannot be found, an empty array (size = 0) is returned. The individual numbers are seperated by the delimeter characters.</p>
<p>Handling of numbers is completly delegated to atof() function. For more info look into the manual.</p>
<p>This function returns a NULL pointer in case of error. </p>

</div>
</div>
<a class="anchor" id="a13b3bb359eb0a37f0501e2283fab2b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(c_int) function, public iniparser::iniparser_getint </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(c_int), intent(in)&#160;</td>
          <td class="paramname"><em>notfound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string associated to a key, convert to an int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to search </td></tr>
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">notfound</td><td>Value to return in case of error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer</dd></dl>
<p>This function queries a dictionary for a key. A key as read from an ini file is given as "section:key". If the key cannot be found, the notfound value is returned.</p>
<p>Supported values for integers include the usual C notation so decimal, octal (starting with 0) and hexadecimal (starting with 0x) are supported. Examples:</p>
<ul>
<li>"42" -&gt; 42</li>
<li>"042" -&gt; 34 (octal -&gt; decimal)</li>
<li>"0x42" -&gt; 66 (hexa -&gt; decimal)</li>
</ul>
<p>Warning: the conversion may overflow in various ways. Conversion is totally outsourced to strtol(), see the associated man page for overflow handling. </p>

</div>
</div>
<a class="anchor" id="ae071c7cc51de3533eb06aec53285eaf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(c_int) function, dimension(:), allocatable, public iniparser::iniparser_getint_array </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(c_int), intent(in)&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string associated to a key, convert to an int array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to search </td></tr>
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">delimiters</td><td>Delimiter characters </td></tr>
    <tr><td class="paramname">size</td><td>Contains the number of result elements after runtime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocatable integer array</dd></dl>
<p>This function queries a dictionary for a key. A key as read from an ini file is given as "section:key". If the key cannot be found, an empty array (size = 0) is returned. The individual numbers are seperated by the delimeter characters.</p>
<p>Supported values for integers include the usual C notation so decimal, octal (starting with 0) and hexadecimal (starting with 0x) are supported. Examples:</p>
<p>"42" -&gt; 42 "042" -&gt; 34 (octal -&gt; decimal) "0x42" -&gt; 66 (hexa -&gt; decimal)</p>
<p>Warning: the conversion may overflow in various ways. Conversion is totally outsourced to strtol(), see the associated man page for overflow handling.</p>
<p>This function returns a NULL pointer in case of error. </p>

</div>
</div>
<a class="anchor" id="a13ebcb955f6d27429934efb2f9444371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(c_int) function, public iniparser::iniparser_getnsec </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of sections in a dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer(c_int) Number of sections found in dictionary This function returns the number of sections found in a dictionary. The test to recognize sections is done on the string stored in the dictionary: a section name is given as "section" whereas a key is stored as "section:key", thus the test looks for entries that do not contain a colon.</dd></dl>
<p>This clearly fails in the case a section name contains a colon, but this should simply be avoided.</p>
<p>This function returns -1 in case of error. </p>

</div>
</div>
<a class="anchor" id="a756ebf793bbe3b428ec2e656bea7a4e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iniparser::iniparser_getseckeys </td>
          <td>(</td>
          <td class="paramtype">character(len=*,kind=c_char), dimension(:), intent(out), allocatable&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(c_int), intent(in)&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of keys in a section of a dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>String array which contains the results after runtime </td></tr>
    <tr><td class="paramname">dic</td><td>Dictionary to examine </td></tr>
    <tr><td class="paramname">sec</td><td>Section name of dictionary to examine </td></tr>
    <tr><td class="paramname">size</td><td>Contains the number of result elements after runtime</td></tr>
  </table>
  </dd>
</dl>
<p>This function queries a dictionary and finds all keys in a given section. Each pointer in the returned char pointer-to-pointer is pointing to a string allocated in the dictionary; do not free or modify them.</p>
<p>This function returns a zero-sized array in case of error. </p>

</div>
</div>
<a class="anchor" id="a86fd5cd849d81f39223ec53605c5a9ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iniparser::iniparser_getsecname </td>
          <td>(</td>
          <td class="paramtype">character(len=*), intent(out)&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(c_int), intent(in)&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name for section n in a dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>String variable which contains the result after runtime </td></tr>
    <tr><td class="paramname">dic</td><td>Dictionary to examine </td></tr>
    <tr><td class="paramname">n</td><td>Section number (from 0 to nsec-1)</td></tr>
  </table>
  </dd>
</dl>
<p>This function locates the n-th section in a dictionary and returns its name.</p>
<p>This function returns an empty string in case of error. </p>

</div>
</div>
<a class="anchor" id="a0b432013880ab3fec116bf2841a72f92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(c_int) function, public iniparser::iniparser_getsecnkeys </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of keys in a section of a dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to examine </td></tr>
    <tr><td class="paramname">sec</td><td>Section name of dictionary to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of keys in section </dd></dl>

</div>
</div>
<a class="anchor" id="aefe9e758f48c9ea76b3105690ebb373a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iniparser::iniparser_getstring </td>
          <td>(</td>
          <td class="paramtype">character(len=*), intent(out)&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>notfound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string associated to a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>String variable which contains the result after runtime </td></tr>
    <tr><td class="paramname">dic</td><td>Dictionary to search </td></tr>
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">notfound</td><td>Default value to return if key not found.</td></tr>
  </table>
  </dd>
</dl>
<p>This function queries a dictionary for a key. A key as read from an ini file is given as "section:key". If the key cannot be found, the pointer passed as 'def' is returned. The returned char pointer is pointing to a string allocated in the dictionary, do not free or modify it. </p>

</div>
</div>
<a class="anchor" id="aca6b564de064e7ae017e86cdf8814ca9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iniparser::iniparser_getstring_array </td>
          <td>(</td>
          <td class="paramtype">character(len=*,kind=c_char), dimension(:), intent(out), allocatable&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(c_int), intent(in)&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string associated to a key, split to an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>String array which contains the results after runtime </td></tr>
    <tr><td class="paramname">dic</td><td>Dictionary to search </td></tr>
    <tr><td class="paramname">key</td><td>Key string to look for </td></tr>
    <tr><td class="paramname">delimiters</td><td>Delimiter characters </td></tr>
    <tr><td class="paramname">size</td><td>Contains the number of result elements after runtime</td></tr>
  </table>
  </dd>
</dl>
<p>This function queries a dictionary for a key. A key as read from an ini file is given as "section:key". If the key cannot be found, an empty array (size = 0) is returned. The string will be split at every delimeter character.</p>
<p>This function returns a zero-sized array in case of error. </p>

</div>
</div>
<a class="anchor" id="a7833514730d102660a1af7ad2a2005b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(c_ptr) function, public iniparser::iniparser_load </td>
          <td>(</td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>ininame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an ini file and return an allocated dictionary object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ininame</td><td>Name of the ini file to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer(c_ptr) to newly allocated dictionary</dd></dl>
<p>This is the parser for ini files. This function is called, providing the name of the file to be read. It returns a dictionary object that should not be accessed directly, but through accessor functions instead.</p>
<p>The returned dictionary must be freed using <a class="el" href="classiniparser.html#af96fa5470ed9fa49b729ce91a2846ab6" title="Free all memory associated to an ini dictionary.">iniparser_freedict()</a>. </p>

</div>
</div>
<a class="anchor" id="a4ca3219d1e80cb89da0576ce273935a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(c_int) function, public iniparser::iniparser_set </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an entry in a dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to modify. </td></tr>
    <tr><td class="paramname">key</td><td>Key to modify </td></tr>
    <tr><td class="paramname">value</td><td>New value to associate to the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer: 0 if Ok, -1 otherwise.</dd></dl>
<p>If the given entry can be found in the dictionary, it is modified to contain the provided value. If it cannot be found, -1 is returned. It is Ok to set value to an empty string (""). </p>

</div>
</div>
<a class="anchor" id="a82e39a4b26f87a3ea69b1813639b4f26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iniparser::iniparser_unset </td>
          <td>(</td>
          <td class="paramtype">type(c_ptr)&#160;</td>
          <td class="paramname"><em>dic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*, kind=c_char), intent(in)&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an entry in a dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dic</td><td>Dictionary to modify </td></tr>
    <tr><td class="paramname">key</td><td>Key to delete</td></tr>
  </table>
  </dd>
</dl>
<p>If the given entry can be found, it is deleted from the dictionary. </p>

</div>
</div>
<hr/>The documentation for this module was generated from the following file:<ul>
<li><a class="el" href="iniparser__wrapper_8f90.html">iniparser_wrapper.f90</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 9 2013 22:25:46 for iniparser by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
